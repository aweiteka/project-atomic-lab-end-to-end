<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
    "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="application/xhtml+xml; charset=UTF-8" />
<meta name="generator" content="AsciiDoc 8.6.8" />
<title>Project Atomic Lab: End to End</title>
<style type="text/css">
/* Shared CSS for AsciiDoc xhtml11 and html5 backends */

/* Default font. */
body {
  font-family: Georgia,serif;
}

/* Title font. */
h1, h2, h3, h4, h5, h6,
div.title, caption.title,
thead, p.table.header,
#toctitle,
#author, #revnumber, #revdate, #revremark,
#footer {
  font-family: Arial,Helvetica,sans-serif;
}

body {
  margin: 1em 5% 1em 5%;
}

a {
  color: blue;
  text-decoration: underline;
}
a:visited {
  color: fuchsia;
}

em {
  font-style: italic;
  color: navy;
}

strong {
  font-weight: bold;
  color: #083194;
}

h1, h2, h3, h4, h5, h6 {
  color: #527bbd;
  margin-top: 1.2em;
  margin-bottom: 0.5em;
  line-height: 1.3;
}

h1, h2, h3 {
  border-bottom: 2px solid silver;
}
h2 {
  padding-top: 0.5em;
}
h3 {
  float: left;
}
h3 + * {
  clear: left;
}
h5 {
  font-size: 1.0em;
}

div.sectionbody {
  margin-left: 0;
}

hr {
  border: 1px solid silver;
}

p {
  margin-top: 0.5em;
  margin-bottom: 0.5em;
}

ul, ol, li > p {
  margin-top: 0;
}
ul > li     { color: #aaa; }
ul > li > * { color: black; }

.monospaced, code, pre {
  font-family: "Courier New", Courier, monospace;
  font-size: inherit;
  color: navy;
  padding: 0;
  margin: 0;
}


#author {
  color: #527bbd;
  font-weight: bold;
  font-size: 1.1em;
}
#email {
}
#revnumber, #revdate, #revremark {
}

#footer {
  font-size: small;
  border-top: 2px solid silver;
  padding-top: 0.5em;
  margin-top: 4.0em;
}
#footer-text {
  float: left;
  padding-bottom: 0.5em;
}
#footer-badges {
  float: right;
  padding-bottom: 0.5em;
}

#preamble {
  margin-top: 1.5em;
  margin-bottom: 1.5em;
}
div.imageblock, div.exampleblock, div.verseblock,
div.quoteblock, div.literalblock, div.listingblock, div.sidebarblock,
div.admonitionblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.admonitionblock {
  margin-top: 2.0em;
  margin-bottom: 2.0em;
  margin-right: 10%;
  color: #606060;
}

div.content { /* Block element content. */
  padding: 0;
}

/* Block element titles. */
div.title, caption.title {
  color: #527bbd;
  font-weight: bold;
  text-align: left;
  margin-top: 1.0em;
  margin-bottom: 0.5em;
}
div.title + * {
  margin-top: 0;
}

td div.title:first-child {
  margin-top: 0.0em;
}
div.content div.title:first-child {
  margin-top: 0.0em;
}
div.content + div.title {
  margin-top: 0.0em;
}

div.sidebarblock > div.content {
  background: #ffffee;
  border: 1px solid #dddddd;
  border-left: 4px solid #f0f0f0;
  padding: 0.5em;
}

div.listingblock > div.content {
  border: 1px solid #dddddd;
  border-left: 5px solid #f0f0f0;
  background: #f8f8f8;
  padding: 0.5em;
}

div.quoteblock, div.verseblock {
  padding-left: 1.0em;
  margin-left: 1.0em;
  margin-right: 10%;
  border-left: 5px solid #f0f0f0;
  color: #888;
}

div.quoteblock > div.attribution {
  padding-top: 0.5em;
  text-align: right;
}

div.verseblock > pre.content {
  font-family: inherit;
  font-size: inherit;
}
div.verseblock > div.attribution {
  padding-top: 0.75em;
  text-align: left;
}
/* DEPRECATED: Pre version 8.2.7 verse style literal block. */
div.verseblock + div.attribution {
  text-align: left;
}

div.admonitionblock .icon {
  vertical-align: top;
  font-size: 1.1em;
  font-weight: bold;
  text-decoration: underline;
  color: #527bbd;
  padding-right: 0.5em;
}
div.admonitionblock td.content {
  padding-left: 0.5em;
  border-left: 3px solid #dddddd;
}

div.exampleblock > div.content {
  border-left: 3px solid #dddddd;
  padding-left: 0.5em;
}

div.imageblock div.content { padding-left: 0; }
span.image img { border-style: none; }
a.image:visited { color: white; }

dl {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
dt {
  margin-top: 0.5em;
  margin-bottom: 0;
  font-style: normal;
  color: navy;
}
dd > *:first-child {
  margin-top: 0.1em;
}

ul, ol {
    list-style-position: outside;
}
ol.arabic {
  list-style-type: decimal;
}
ol.loweralpha {
  list-style-type: lower-alpha;
}
ol.upperalpha {
  list-style-type: upper-alpha;
}
ol.lowerroman {
  list-style-type: lower-roman;
}
ol.upperroman {
  list-style-type: upper-roman;
}

div.compact ul, div.compact ol,
div.compact p, div.compact p,
div.compact div, div.compact div {
  margin-top: 0.1em;
  margin-bottom: 0.1em;
}

tfoot {
  font-weight: bold;
}
td > div.verse {
  white-space: pre;
}

div.hdlist {
  margin-top: 0.8em;
  margin-bottom: 0.8em;
}
div.hdlist tr {
  padding-bottom: 15px;
}
dt.hdlist1.strong, td.hdlist1.strong {
  font-weight: bold;
}
td.hdlist1 {
  vertical-align: top;
  font-style: normal;
  padding-right: 0.8em;
  color: navy;
}
td.hdlist2 {
  vertical-align: top;
}
div.hdlist.compact tr {
  margin: 0;
  padding-bottom: 0;
}

.comment {
  background: yellow;
}

.footnote, .footnoteref {
  font-size: 0.8em;
}

span.footnote, span.footnoteref {
  vertical-align: super;
}

#footnotes {
  margin: 20px 0 20px 0;
  padding: 7px 0 0 0;
}

#footnotes div.footnote {
  margin: 0 0 5px 0;
}

#footnotes hr {
  border: none;
  border-top: 1px solid silver;
  height: 1px;
  text-align: left;
  margin-left: 0;
  width: 20%;
  min-width: 100px;
}

div.colist td {
  padding-right: 0.5em;
  padding-bottom: 0.3em;
  vertical-align: top;
}
div.colist td img {
  margin-top: 0.3em;
}

@media print {
  #footer-badges { display: none; }
}

#toc {
  margin-bottom: 2.5em;
}

#toctitle {
  color: #527bbd;
  font-size: 1.1em;
  font-weight: bold;
  margin-top: 1.0em;
  margin-bottom: 0.1em;
}

div.toclevel0, div.toclevel1, div.toclevel2, div.toclevel3, div.toclevel4 {
  margin-top: 0;
  margin-bottom: 0;
}
div.toclevel2 {
  margin-left: 2em;
  font-size: 0.9em;
}
div.toclevel3 {
  margin-left: 4em;
  font-size: 0.9em;
}
div.toclevel4 {
  margin-left: 6em;
  font-size: 0.9em;
}

span.aqua { color: aqua; }
span.black { color: black; }
span.blue { color: blue; }
span.fuchsia { color: fuchsia; }
span.gray { color: gray; }
span.green { color: green; }
span.lime { color: lime; }
span.maroon { color: maroon; }
span.navy { color: navy; }
span.olive { color: olive; }
span.purple { color: purple; }
span.red { color: red; }
span.silver { color: silver; }
span.teal { color: teal; }
span.white { color: white; }
span.yellow { color: yellow; }

span.aqua-background { background: aqua; }
span.black-background { background: black; }
span.blue-background { background: blue; }
span.fuchsia-background { background: fuchsia; }
span.gray-background { background: gray; }
span.green-background { background: green; }
span.lime-background { background: lime; }
span.maroon-background { background: maroon; }
span.navy-background { background: navy; }
span.olive-background { background: olive; }
span.purple-background { background: purple; }
span.red-background { background: red; }
span.silver-background { background: silver; }
span.teal-background { background: teal; }
span.white-background { background: white; }
span.yellow-background { background: yellow; }

span.big { font-size: 2em; }
span.small { font-size: 0.6em; }

span.underline { text-decoration: underline; }
span.overline { text-decoration: overline; }
span.line-through { text-decoration: line-through; }

div.unbreakable { page-break-inside: avoid; }


/*
 * xhtml11 specific
 *
 * */

div.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
div.tableblock > table {
  border: 3px solid #527bbd;
}
thead, p.table.header {
  font-weight: bold;
  color: #527bbd;
}
p.table {
  margin-top: 0;
}
/* Because the table frame attribute is overriden by CSS in most browsers. */
div.tableblock > table[frame="void"] {
  border-style: none;
}
div.tableblock > table[frame="hsides"] {
  border-left-style: none;
  border-right-style: none;
}
div.tableblock > table[frame="vsides"] {
  border-top-style: none;
  border-bottom-style: none;
}


/*
 * html5 specific
 *
 * */

table.tableblock {
  margin-top: 1.0em;
  margin-bottom: 1.5em;
}
thead, p.tableblock.header {
  font-weight: bold;
  color: #527bbd;
}
p.tableblock {
  margin-top: 0;
}
table.tableblock {
  border-width: 3px;
  border-spacing: 0px;
  border-style: solid;
  border-color: #527bbd;
  border-collapse: collapse;
}
th.tableblock, td.tableblock {
  border-width: 1px;
  padding: 4px;
  border-style: solid;
  border-color: #527bbd;
}

table.tableblock.frame-topbot {
  border-left-style: hidden;
  border-right-style: hidden;
}
table.tableblock.frame-sides {
  border-top-style: hidden;
  border-bottom-style: hidden;
}
table.tableblock.frame-none {
  border-style: hidden;
}

th.tableblock.halign-left, td.tableblock.halign-left {
  text-align: left;
}
th.tableblock.halign-center, td.tableblock.halign-center {
  text-align: center;
}
th.tableblock.halign-right, td.tableblock.halign-right {
  text-align: right;
}

th.tableblock.valign-top, td.tableblock.valign-top {
  vertical-align: top;
}
th.tableblock.valign-middle, td.tableblock.valign-middle {
  vertical-align: middle;
}
th.tableblock.valign-bottom, td.tableblock.valign-bottom {
  vertical-align: bottom;
}


/*
 * manpage specific
 *
 * */

body.manpage h1 {
  padding-top: 0.5em;
  padding-bottom: 0.5em;
  border-top: 2px solid silver;
  border-bottom: 2px solid silver;
}
body.manpage h2 {
  border-style: none;
}
body.manpage div.sectionbody {
  margin-left: 3em;
}

@media print {
  body.manpage div#toc { display: none; }
}


</style>
<script type="text/javascript">
/*<![CDATA[*/
var asciidoc = {  // Namespace.

/////////////////////////////////////////////////////////////////////
// Table Of Contents generator
/////////////////////////////////////////////////////////////////////

/* Author: Mihai Bazon, September 2002
 * http://students.infoiasi.ro/~mishoo
 *
 * Table Of Content generator
 * Version: 0.4
 *
 * Feel free to use this script under the terms of the GNU General Public
 * License, as long as you do not remove or alter this notice.
 */

 /* modified by Troy D. Hanson, September 2006. License: GPL */
 /* modified by Stuart Rackham, 2006, 2009. License: GPL */

// toclevels = 1..4.
toc: function (toclevels) {

  function getText(el) {
    var text = "";
    for (var i = el.firstChild; i != null; i = i.nextSibling) {
      if (i.nodeType == 3 /* Node.TEXT_NODE */) // IE doesn't speak constants.
        text += i.data;
      else if (i.firstChild != null)
        text += getText(i);
    }
    return text;
  }

  function TocEntry(el, text, toclevel) {
    this.element = el;
    this.text = text;
    this.toclevel = toclevel;
  }

  function tocEntries(el, toclevels) {
    var result = new Array;
    var re = new RegExp('[hH]([1-'+(toclevels+1)+'])');
    // Function that scans the DOM tree for header elements (the DOM2
    // nodeIterator API would be a better technique but not supported by all
    // browsers).
    var iterate = function (el) {
      for (var i = el.firstChild; i != null; i = i.nextSibling) {
        if (i.nodeType == 1 /* Node.ELEMENT_NODE */) {
          var mo = re.exec(i.tagName);
          if (mo && (i.getAttribute("class") || i.getAttribute("className")) != "float") {
            result[result.length] = new TocEntry(i, getText(i), mo[1]-1);
          }
          iterate(i);
        }
      }
    }
    iterate(el);
    return result;
  }

  var toc = document.getElementById("toc");
  if (!toc) {
    return;
  }

  // Delete existing TOC entries in case we're reloading the TOC.
  var tocEntriesToRemove = [];
  var i;
  for (i = 0; i < toc.childNodes.length; i++) {
    var entry = toc.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div'
     && entry.getAttribute("class")
     && entry.getAttribute("class").match(/^toclevel/))
      tocEntriesToRemove.push(entry);
  }
  for (i = 0; i < tocEntriesToRemove.length; i++) {
    toc.removeChild(tocEntriesToRemove[i]);
  }

  // Rebuild TOC entries.
  var entries = tocEntries(document.getElementById("content"), toclevels);
  for (var i = 0; i < entries.length; ++i) {
    var entry = entries[i];
    if (entry.element.id == "")
      entry.element.id = "_toc_" + i;
    var a = document.createElement("a");
    a.href = "#" + entry.element.id;
    a.appendChild(document.createTextNode(entry.text));
    var div = document.createElement("div");
    div.appendChild(a);
    div.className = "toclevel" + entry.toclevel;
    toc.appendChild(div);
  }
  if (entries.length == 0)
    toc.parentNode.removeChild(toc);
},


/////////////////////////////////////////////////////////////////////
// Footnotes generator
/////////////////////////////////////////////////////////////////////

/* Based on footnote generation code from:
 * http://www.brandspankingnew.net/archive/2005/07/format_footnote.html
 */

footnotes: function () {
  // Delete existing footnote entries in case we're reloading the footnodes.
  var i;
  var noteholder = document.getElementById("footnotes");
  if (!noteholder) {
    return;
  }
  var entriesToRemove = [];
  for (i = 0; i < noteholder.childNodes.length; i++) {
    var entry = noteholder.childNodes[i];
    if (entry.nodeName.toLowerCase() == 'div' && entry.getAttribute("class") == "footnote")
      entriesToRemove.push(entry);
  }
  for (i = 0; i < entriesToRemove.length; i++) {
    noteholder.removeChild(entriesToRemove[i]);
  }

  // Rebuild footnote entries.
  var cont = document.getElementById("content");
  var spans = cont.getElementsByTagName("span");
  var refs = {};
  var n = 0;
  for (i=0; i<spans.length; i++) {
    if (spans[i].className == "footnote") {
      n++;
      var note = spans[i].getAttribute("data-note");
      if (!note) {
        // Use [\s\S] in place of . so multi-line matches work.
        // Because JavaScript has no s (dotall) regex flag.
        note = spans[i].innerHTML.match(/\s*\[([\s\S]*)]\s*/)[1];
        spans[i].innerHTML =
          "[<a id='_footnoteref_" + n + "' href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
        spans[i].setAttribute("data-note", note);
      }
      noteholder.innerHTML +=
        "<div class='footnote' id='_footnote_" + n + "'>" +
        "<a href='#_footnoteref_" + n + "' title='Return to text'>" +
        n + "</a>. " + note + "</div>";
      var id =spans[i].getAttribute("id");
      if (id != null) refs["#"+id] = n;
    }
  }
  if (n == 0)
    noteholder.parentNode.removeChild(noteholder);
  else {
    // Process footnoterefs.
    for (i=0; i<spans.length; i++) {
      if (spans[i].className == "footnoteref") {
        var href = spans[i].getElementsByTagName("a")[0].getAttribute("href");
        href = href.match(/#.*/)[0];  // Because IE return full URL.
        n = refs[href];
        spans[i].innerHTML =
          "[<a href='#_footnote_" + n +
          "' title='View footnote' class='footnote'>" + n + "</a>]";
      }
    }
  }
},

install: function(toclevels) {
  var timerId;

  function reinstall() {
    asciidoc.footnotes();
    if (toclevels) {
      asciidoc.toc(toclevels);
    }
  }

  function reinstallAndRemoveTimer() {
    clearInterval(timerId);
    reinstall();
  }

  timerId = setInterval(reinstall, 500);
  if (document.addEventListener)
    document.addEventListener("DOMContentLoaded", reinstallAndRemoveTimer, false);
  else
    window.onload = reinstallAndRemoveTimer;
}

}
asciidoc.install(2);
/*]]>*/
</script>
</head>
<body class="article">
<div id="header">
<h1>Project Atomic Lab: End to End</h1>
<span id="author">&lt;scollier@redhat.com&gt;</span><br />
<span id="revdate">Updated</span>
<br /><span id="revremark">2014-05-19 10:57</span>
<div id="toc">
  <div id="toctitle">Table of Contents</div>
  <noscript><p><b>JavaScript must be enabled in your browser to display the table of contents.</b></p></noscript>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_introduction">Introduction</h2>
<div class="sectionbody">
<div class="paragraph"><p>Project Atomic and Docker are very fast moving spaces at the moment.  There is a already lot of existing documentation out there.  This lab attempts to make use of some of that documentation and provide a comprehensive example of an end to end deployment using Project Atomic components.  Considering how fast moving this space is, if you use this guide and find some steps, or anything out of date, please submite a PR and let&#8217;s get it fixed. I will try to include links to external documentation that I borrowed from when possible.</p></div>
</div>
</div>
<div class="sect1">
<h2 id="Compose_Server_Setup">Red Hat Enterprise Linux Atomic Host Compose Server</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_configure_the_compose_server">Configure the Compose Server</h3>
<div class="paragraph"><p>The Atomic compose server builds the trees of content that the Red Hat Enterprise Linux Atomic Hosts consume.</p></div>
</div>
<div class="sect2">
<h3 id="_deploy_a_red_hat_enterprise_linux_7_virtual_machine">Deploy a Red Hat Enterprise Linux 7 Virtual Machine</h3>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img alt="Note" src="data:image/png;base64,
" />
</td>
<td class="content">Perform this on the hypervisor</td>
</tr></table>
</div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Create the directory structure, from <em>roots</em> home directory
</p>
<div class="listingblock">
<div class="content">
<pre><code>cd ~
mkdir atomic/build_server</code></pre>
</div></div>
</li>
<li>
<p>
Download the image
</p>
<div class="listingblock">
<div class="content">
<pre><code>cd atomic/build_server
wget http://download.devel.redhat.com/brewroot/packages/rhel-server-kvm/7.0/7/images/rhel-server-kvm-7.0-7.x86_64.qcow2</code></pre>
</div></div>
</li>
<li>
<p>
Change the password on the image
</p>
<div class="listingblock">
<div class="content">
<pre><code>virt-sysprep -a rhel-server-kvm-7.0-7.x86_64.qcow2 --root-password password:redhat</code></pre>
</div></div>
</li>
<li>
<p>
Install the Red Hat Enterprise Linux image
</p>
<div class="listingblock">
<div class="content">
<pre><code>cd atomic/build_server
virt-install \
  --memory 4096 \
  --name Compose_Server \
  --disk ~/atomic/build_server/rhel-server-kvm-7.0-7.x86_64.qcow2 \
  --import \
  --noautoconsole</code></pre>
</div></div>
</li>
<li>
<p>
Configure SSH, do this from within the virtual console
</p>
<div class="listingblock">
<div class="content">
<pre><code>sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/' /etc/ssh/sshd_config
grep -i passwordauth /etc/ssh/sshd_config
systemctl restart sshd</code></pre>
</div></div>
</li>
<li>
<p>
Get the IP address from the image and SSH in, instead of using the virt-console
</p>
</li>
<li>
<p>
Now you should be SSH&#8217;d into the VM.  Add the collider repo for RHEL internal content
</p>
</li>
</ol></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img alt="Note" src="data:image/png;base64,
" />
</td>
<td class="content">Perform on the build server</td>
</tr></table>
</div>
<div class="listingblock">
<div class="content">
<pre><code>cat &lt;&lt; EOF &gt; /etc/yum.repos.d/collider.repo
[collider-rhel-7]
name=Collider RHEL 7 Packages
baseurl=http://download.lab.bos.redhat.com/brewroot/repos/collider-rhel-7-build/latest/x86_64/
enabled=1
gpgcheck=0
EOF</code></pre>
</div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Install <em>rpm-ostree</em> tools
</p>
<div class="listingblock">
<div class="content">
<pre><code>yum -y install httpd yum-utils ostree binutils nss-altfiles firewalld</code></pre>
</div></div>
</li>
<li>
<p>
Edit the <em>/etc/nsswitch.conf</em> file
</p>
<div class="listingblock">
<div class="content">
<pre><code>sed -i 's/passwd:     files sss/passwd:     files sss altfiles/' /etc/nsswitch.conf
sed -i 's/shadow:     files sss/passwd:     files sss altfiles/' /etc/nsswitch.conf</code></pre>
</div></div>
</li>
<li>
<p>
Disable SELinux on the compose server
</p>
<div class="listingblock">
<div class="content">
<pre><code>sed -i 's/^SELINUX=.*/SELINUX=disabled/g' /etc/selinux/config &amp;&amp; cat /etc/selinux/config</code></pre>
</div></div>
</li>
<li>
<p>
Create the repo and set up Apache
</p>
<div class="listingblock">
<div class="content">
<pre><code>mkdir /srv/rpm-ostree &amp;&amp;
cd /srv/rpm-ostree &amp;&amp;
mkdir -p repo &amp;&amp;
ostree --repo=repo init --mode=archive-z2 &amp;&amp;

cat &gt; /etc/httpd/conf.d/rpm-ostree.conf &lt;&lt;EOF
DocumentRoot /srv/rpm-ostree
&lt;Directory "/srv/rpm-ostree"&gt;
Options Indexes FollowSymLinks
AllowOverride None
Require all granted
&lt;/Directory&gt;
EOF</code></pre>
</div></div>
</li>
<li>
<p>
Create a systemd service file
</p>
<div class="listingblock">
<div class="content">
<pre><code>cat &gt; /etc/systemd/system/rpm-ostree-autobuilder.service &lt;&lt;EOF
[Unit]
Description=RPM-OSTree autobuilder

[Service]
WorkingDirectory=/srv/rpm-ostree
ExecStart=/usr/bin/rpm-ostree-autobuilder

[Install]
WantedBy=multi-user.target
EOF</code></pre>
</div></div>
</li>
<li>
<p>
Enable services and configure firewall
</p>
<div class="listingblock">
<div class="content">
<pre><code>systemctl start firewalld &amp;&amp;
systemctl enable firewalld &amp;&amp;
systemctl daemon-reload &amp;&amp;
systemctl enable httpd &amp;&amp;
systemctl start httpd &amp;&amp;
systemctl reload httpd &amp;&amp;
systemctl enable rpm-ostree-autobuilder &amp;&amp;
systemctl start rpm-ostree-autobuilder &amp;&amp;
firewall-cmd --add-service=http &amp;&amp;
firewall-cmd --add-service=http --permanent</code></pre>
</div></div>
</li>
<li>
<p>
Reboot the host
</p>
<div class="listingblock">
<div class="content">
<pre><code>systemctl reboot</code></pre>
</div></div>
</li>
<li>
<p>
Create the <em>products.json</em> file
</p>
<div class="listingblock">
<div class="content">
<pre><code>cat &gt; /srv/rpm-ostree/products.json &lt;&lt; EOF
{
    "comment": "Red Hat Enterprise Linux Atomic Host 7.0",

    "osname": "rhel-atomic-host",
    "ref": "rhel-atomic-host/7.0-buildmaster/x86_64/base",

    "repos": ["collider-rhel-7-build", "collider-rhel-7-candidate"],

    "selinux": true,

    "bootstrap_packages": ["filesystem", "glibc", "nss-altfiles", "shadow-utils",
         "redhat-release-atomic-controller"],

    "packages": ["kernel", "rpm-ostree", "lvm2", "syslinux-extlinux",
     "btrfs-progs", "e2fsprogs", "xfsprogs",
     "docker",
     "selinux-policy-targeted",
     "audit",
     "min-cloud-agent",
     "subscription-manager",
     "openssh-server", "openssh-clients",
     "passwd",
     "NetworkManager", "vim-minimal", "nano",
     "sudo"],

    "units": ["docker.service", "docker.socket"]
}
EOF</code></pre>
</div></div>
</li>
</ol></div>
<div class="paragraph"><p>FIXME NEED PACKAGE FROM COLLIDER BEFORE COMPLETING THIS SECTION</p></div>
<div class="sect3">
<h4 id="_links">Links</h4>
<div class="paragraph"><p><a href="http://www.projectatomic.io/blog/2014/04/build-your-own-atomic-host-on-fedora-20/">http://www.projectatomic.io/blog/2014/04/build-your-own-atomic-host-on-fedora-20/</a></p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Configure_PA_VMs">Configure Project Atomic VMs</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_options_for_deployment">Options for Deployment</h3>
<div class="paragraph"><p>There are a few different ways to obtain Atomic images.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
In .qcow2 format
</p>
</li>
<li>
<p>
Deploy from rpm
</p>
</li>
</ol></div>
<div class="paragraph"><p>For the purposes of this lab, we will be deploying Red Hat Enterprise Linux Atomic Controllers via the .qcow2 pre-built images.</p></div>
</div>
<div class="sect2">
<h3 id="_obtaining_the_images">Obtaining the images</h3>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
On the host running the VM&#8217;s, create the directory structure.
</p>
<div class="listingblock">
<div class="content">
<pre><code>cd ~
mkdir -p atomic/{1,2}</code></pre>
</div></div>
</li>
<li>
<p>
Download and decompress the images to the appropriate directories.  You only need to do the following step if the images haven&#8217;t been downloaded for you already.
</p>
<div class="listingblock">
<div class="content">
<pre><code>cd ~
for i in 1 2; do
  pushd atomic/$i/;
  wget http://rcm-img06.build.bos.redhat.com/images/auto/rh-atomic-controller-el7-x86_64-buildmaster-controller-docker/latest-qcow2.xz;
  xz -d latest-qcow2.xz;
  popd;
done</code></pre>
</div></div>
</li>
<li>
<p>
Install the image and create an additional drive
</p>
<div class="listingblock">
<div class="content">
<pre><code>cd ~
for i in 1 2; do
  pushd atomic/$i/;
  sudo virt-install \
  --memory 2048 \
  --name Atomic_Host_$i \
  --disk latest-qcow2 \
  --import \
  --noautoconsole \
  --disk /root/atomic/$i/storage_$i.qcow2,format=qcow2,sparse=true,size=10;
  popd;
done</code></pre>
</div></div>
</li>
<li>
<p>
Set a password for the <em>root</em> user on each Atomic host.
</p>
</li>
<li>
<p>
Get IP Address of both hosts and open up a terminal console to each machine.
</p>
</li>
</ol></div>
</div>
<div class="sect2">
<h3 id="_configure_disk_partitions">Configure Disk Partitions</h3>
<div class="paragraph"><p>The Red Hat Enterprise Linux Atomic Controllers come with a fairly small disk image.  We need to confiure the second disk that was added with <em>virt-install</em> and mount that under <em>/var/lib/docker</em>.</p></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img alt="Note" src="data:image/png;base64,
" />
</td>
<td class="content"><span class="yellow-background">Ensure you are on the correct host!  It would not be good if you are on the wrong host.  You should be on the Atomic VM&#8217;s when you perform the following operation.</span></td>
</tr></table>
</div>
<div class="listingblock">
<div class="content">
<pre><code>cat &lt;&lt; EOF &gt; Atomic_Host_sdb.layout
# partition table of /dev/sdb
unit: sectors

/dev/sdb1 : start=     2048, size= 20969472, Id=83
/dev/sdb2 : start=        0, size=        0, Id= 0
/dev/sdb3 : start=        0, size=        0, Id= 0
/dev/sdb4 : start=        0, size=        0, Id= 0
EOF

sfdisk /dev/sdb &lt; Atomic_Host_sdb.layout</code></pre>
</div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Format <em>/dev/sdb1</em>
</p>
<div class="listingblock">
<div class="content">
<pre><code>mkfs.xfs /dev/sdb1</code></pre>
</div></div>
</li>
<li>
<p>
Ensure that only <em>/dev/sdb1</em> is mounted to <em>/var/lib/docker</em>
</p>
<div class="listingblock">
<div class="content">
<pre><code>systemctl stop docker
mount
df -hal
umount /var/lib/docker
mount</code></pre>
</div></div>
</li>
<li>
<p>
Get the UUID from <em>/dev/sdb1</em> and add it to the <em>/etc/fstab</em>
</p>
<div class="listingblock">
<div class="content">
<pre><code>cp /etc/fstab{,.orig}
cat /etc/fstab
echo "$(blkid /dev/sdb1 | awk '{ print $2 }') /var/lib/docker xfs defaults 1 1" &gt;&gt; /etc/fstab
cat /etc/fstab
mount -a
mount
df -hal
systemctl start docker
ls /var/lib/docker</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect2">
<h3 id="_validate_hostname_and_networking">Validate Hostname and Networking</h3>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Set the hostname for each of your Red Hat Enterprise Linux Atomic Controller&#8217;s.
</p>
<div class="listingblock">
<div class="content">
<pre><code>hostnamectl set-hostname atomic1.local     # on host 1
hostnamectl set-hostname atomic2.local     # on host 2</code></pre>
</div></div>
</li>
<li>
<p>
Ensure you can ping the other controller
</p>
</li>
</ol></div>
</div>
<div class="sect2">
<h3 id="_validate_selinux">Validate SELinux</h3>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Ensure that selinux is set to enforcing mode on each controller.
</p>
<div class="listingblock">
<div class="content">
<pre><code>getenforce</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect2">
<h3 id="_ensure_docker_and_geard_are_functional">Ensure Docker and geard are Functional</h3>
<div class="paragraph"><p>+</p></div>
<div class="listingblock">
<div class="content">
<pre><code>systemctl status docker
systemctl status geard</code></pre>
</div></div>
</div>
<div class="sect2">
<h3 id="_upgrade_both_controllers">Upgrade both controllers.</h3>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Disable GPG support
</p>
<div class="listingblock">
<div class="content">
<pre><code>echo "gpg-verify=false" &gt;&gt; /ostree/repo/config</code></pre>
</div></div>
</li>
<li>
<p>
Run the following on both of the Atomic controllers.
</p>
<div class="listingblock">
<div class="content">
<pre><code>rpm-ostree upgrade
reboot</code></pre>
</div></div>
</li>
</ol></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Building_Images">Building Docker Images</h2>
<div class="sectionbody">
<div class="sect3">
<h4 id="_overview">Overview</h4>
<div class="paragraph"><p>In this section we will build images that will be used through the remainder of the lab.  The Dockerfiles will be provided in the text below, just copy and paste them with the appropriate filenames. The Dockerfiles in this section are just examples.  Some are Fedora, some are RHEL.  Try them both out.</p></div>
<div class="paragraph"><p>This section describes building the images, but doesn&#8217;t go into detail on the usage.  That will be in the following chapters.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Download the Dockerfiles and Scripts to a host that has the <em>tar</em> binary.  The Atomic Hosts do not have this tool by default.  So download it somewhere, extract the files and <em>scp</em> them over.
</p>
<div class="listingblock">
<div class="content">
<pre><code>cd ~
curl -o dockerfiles.tar.bz2 -L https://github.com/scollier/project-atomic-lab-end-to-end/blob/master/content/docker/dockerfiles.tar.bz2?raw=true
tar xjvf dockerfiles.tar.bz2</code></pre>
</div></div>
</li>
<li>
<p>
Copy the Atomic Host 1 directory from the tar file to Atomic Host 1. Replace <em>x.x.x.x</em> with the IP address of Atomic Host 1.
</p>
<div class="listingblock">
<div class="content">
<pre><code>cd ~
scp -r Dockerfiles/atomic_host_1 root@x.x.x.x:</code></pre>
</div></div>
</li>
<li>
<p>
Copy the Atomic Host 2 directory from the tar file to Atomic Host 2. Replace <em>x.x.x.x</em> with the IP address of Atomic Host 2.
</p>
<div class="listingblock">
<div class="content">
<pre><code>cd ~
scp -r Dockerfiles/atomic_host_2 root@x.x.x.x:</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect3">
<h4 id="_apache_image_atomic_host_1">Apache Image Atomic Host 1</h4>
<div class="paragraph"><p>Build this image on Atomic Host 1</p></div>
<div class="listingblock">
<div class="content">
<pre><code>docker images
cd ~/atomic_host_1/apache
docker build -t demo/apache .</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_apache_image_atomic_host_2">Apache Image Atomic Host 2</h4>
<div class="paragraph"><p>Build this image on Atomic Host 1</p></div>
<div class="listingblock">
<div class="content">
<pre><code>docker images
cd ~/atomic_host_2/apache
docker build -t demo/apache .</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_mediawiki_image">Mediawiki Image</h4>
<div class="paragraph"><p>Build this image on Atomic Host 1
. Build the image</p></div>
<div class="listingblock">
<div class="content">
<pre><code>docker images
cd ~/atomic_host_1/mediawiki
docker build -t demo/mediawiki .</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_mariadb_image">MariaDB Image</h4>
<div class="paragraph"><p>Build this image on Atomic Host 1
. Build the image</p></div>
<div class="listingblock">
<div class="content">
<pre><code>docker images
cd ~/atomic_host_1/mariadb
docker build -t demo/mariadb .</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_mongodb_image">MongoDB Image</h4>
<div class="paragraph"><p>Build this image on Atomic Host 1
. Build the image</p></div>
<div class="listingblock">
<div class="content">
<pre><code>docker images
cd ~/atomic_host_1/mongodb
docker build -t demo/mongodb .</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_links_2">Links</h4>
<div class="paragraph"><p>More example Dockerfiles are on the Fedora Cloud SIG github page:</p></div>
<div class="paragraph"><p><a href="https://github.com/fedora-cloud/Fedora-Dockerfiles">https://github.com/fedora-cloud/Fedora-Dockerfiles</a></p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Docker_Basics">Docker Basics</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_overview_2">Overview</h3>
<div class="paragraph"><p>The rapid adoption of Docker demonstrates that the benefits of Docker and containers in general are valued by enterprise developers and administrators. Specifically, Docker and containers enable rapid application deployment by only including the minimal runtime requirements of the application. This minimal size and the mentality of replacing containers, rather than updating them, simplifies maintenance. Additionally, containers allow applications bring all of their runtime requirements with them, making them to be portable across multiple Red Hat Enterprise Linux environments. This means that containers can ease testing and troubleshooting efforts by providing a consistent runtime across development, QA and production environments. In addition, containers run applications in isolated memory, process, filesystem and networking spaces. The isolation ensures that any security breaches are limited to the container.</p></div>
<div class="paragraph"><p>Red Hat has been investing in containers for a number of years in Red Hat Enterprise Linux and has been working on Docker in the upstream community since mid-2013. Red Hat&#8217;s commitment to Docker and container technology is demonstrated not just in this background work, but also in the efforts to establish Docker containers as a standard part of the Red Hat Enterprise Linux environment. Red Hat has production experience leveraging container technologies like cgroups and namespaces since Red Hat Enterrise Linux 6. Establishing, consuming and sharing these capabilities as a part of Red Hat Enterprise Linux is a major step in making them consumable by enterprise customers.</p></div>
<div class="paragraph"><p>This lab has 3 sections:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Overview
</p>
</li>
<li>
<p>
Lab 1: Docker Environment
</p>
</li>
<li>
<p>
Lab 2: Containers can Talk
</p>
</li>
</ol></div>
<div class="sect3">
<h4 id="_lab_environment">Lab Environment</h4>
<div class="paragraph"><p>Perform all activities on the Red Hat Enterprise Linux Atomic Host 1 unless instructed otherwise.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
SSH Access
</p>
<div class="listingblock">
<div class="content">
<pre><code>ssh root@IPAddress_of_RHELAH1</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect3">
<h4 id="_what_you_can_expect_to_learn_from_this_lab">What you can expect to learn from this lab</h4>
<div class="paragraph"><p>Topics covered:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Explore Docker
</p>
</li>
<li>
<p>
Saving Content
</p>
</li>
<li>
<p>
Host exploration
</p>
</li>
<li>
<p>
External Logging
</p>
</li>
<li>
<p>
Starting containers on boot
</p>
</li>
<li>
<p>
Linking containers
</p>
</li>
</ol></div>
</div>
</div>
<div class="sect2">
<h3 id="_docker_overview">Docker Overview</h3>
<div class="sect3">
<h4 id="_explore_docker">Explore Docker</h4>
<div class="paragraph"><p>All actions in this lab will performed by the user <em>root</em>.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Check to ensure that SELinux is running on the host.
</p>
<div class="listingblock">
<div class="content">
<pre><code>getenforce</code></pre>
</div></div>
</li>
<li>
<p>
Take a look at the documetation and general help as well as command specific help that is provide by the Docker package.
</p>
<div class="listingblock">
<div class="content">
<pre><code>rpm -qd docker
man docker
man docker-run
docker --help
docker run --help</code></pre>
</div></div>
</li>
<li>
<p>
A Docker <em>image</em> is basically a layer.  A layer never changes.  To take a look a the images that are on this system.  There should be <em>nginx</em>,<em>mariadb</em>,mongodb,mediawiki,apache.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker images --help
docker images</code></pre>
</div></div>
</li>
<li>
<p>
Docker provides the <em>run</em> option to run a image.  Check out the <em>run</em> options and then run the image.  The following command launches the image, executes the command <em>echo hello</em>, and then exits.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker run --help
docker run fedora echo hello</code></pre>
</div></div>
</li>
<li>
<p>
Check the logs.  The following commands will list the last container that ran so you can get the UUID and check the logs.  This should return the output of "echo hello".  Finally, run with the <em>-t</em> option to allocate a psuedo-tty.  Note that <em>-l</em> below is lowercase <em>L</em>.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker ps -l
docker logs &lt;Container UUID&gt;</code></pre>
</div></div>
</li>
<li>
<p>
Tag the base image with a new name.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker tag docker-registry.usersys.redhat.com/brew/rhel7 rhel7</code></pre>
</div></div>
</li>
<li>
<p>
To run an interactive instance that you can look around in, pass the options <em>-i</em> and <em>-t</em>. The <em>-i</em> option starts an interactive terminal.  The <em>-t</em> option allocates a pseudo-tty. You should see different results than before.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker run -i -t rhel7 bash</code></pre>
</div></div>
</li>
<li>
<p>
Check out the IP address of the container and also look at the route.  You can see that the default route is that of the <em>docker0</em> bridge on the host.
</p>
<div class="listingblock">
<div class="content">
<pre><code>ip a
hostname</code></pre>
</div></div>
<div class="literalblock">
<div class="content">
<pre><code>This is a slimmed down base image.  There are not many tools on here by default.</code></pre>
</div></div>
</li>
<li>
<p>
Switch to the Fedora image and take a look around. Grab the hostname of the container.  By default the hostname is set to the UUID of the container.  We will look at how to change that later.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker run -i -t fedora bash
ip a
ip r
hostname</code></pre>
</div></div>
</li>
<li>
<p>
What processes are running inside the container?
</p>
<div class="listingblock">
<div class="content">
<pre><code>ps aux</code></pre>
</div></div>
</li>
<li>
<p>
What is the SELinux security label of the processes?
</p>
<div class="listingblock">
<div class="content">
<pre><code>ps -Z</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect3">
<h4 id="_saving_content">Saving Content</h4>
<div class="paragraph"><p>Now that we have an idea of what&#8217;s going on inside the container, let&#8217;s take a look at the process required to save a file.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Create a file inside the container and see if it persists the next time you run the container.
</p>
<div class="listingblock">
<div class="content">
<pre><code>echo "Hello World" &gt;&gt; ~/file1
ls ~/</code></pre>
</div></div>
</li>
<li>
<p>
Exit the container.
</p>
<div class="listingblock">
<div class="content">
<pre><code>exit</code></pre>
</div></div>
</li>
<li>
<p>
Run the container again and check to see if the file exists.  The file should be gone.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker run -i -t fedora bash
ls ~/</code></pre>
</div></div>
</li>
<li>
<p>
Let&#8217;s try this again and this time we&#8217;ll commit the container.
</p>
<div class="listingblock">
<div class="content">
<pre><code>echo "Hello World" &gt;&gt; ~/file2</code></pre>
</div></div>
</li>
<li>
<p>
Exit the container and commit the container.
</p>
<div class="listingblock">
<div class="content">
<pre><code>exit
docker ps -l
docker commit &lt;Container UUID&gt; file2/container
ae4b621fc73d0a66bf1e98657dee570043cb7f9910c0b96782a914fee85437f2</code></pre>
</div></div>
</li>
<li>
<p>
Now lets see if it saved the file.  Now <em>docker images</em> should show the newly commited container. Launch it again and check for the file.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker images
docker run -i -t file2/container bash
ls ~/
exit</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect3">
<h4 id="_host_exploration">Host exploration</h4>
<div class="paragraph"><p>Now that we have explored what&#8217;s on the inside of a container, let&#8217;s see what is going on outside of the container.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Let&#8217;s launch a container that will run for a long time then confirm it is running.  The <em>-d</em> option runs the container in daemon mode.  Remember, you can always get help with the options.  Run these commands on the host (you should not be inside a container at this time).
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker run --help
docker run -d rhel7 sleep 999999</code></pre>
</div></div>
</li>
<li>
<p>
List the images that are currently running on the system.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker ps</code></pre>
</div></div>
</li>
<li>
<p>
Now, check out the networking on the host. You should see the <em>docker0</em> bridge and a <em>veth</em> interface attached.  The <em>veth</em> interface is one end of a virtual device that connects the container to the host machine. You should see that the IP address of the bridge is used as the default gateway of the container that you saw earlier.
</p>
<div class="listingblock">
<div class="content">
<pre><code>ip a</code></pre>
</div></div>
</li>
<li>
<p>
What are the firewall rules on the host?  You can see from the <em>nat</em> table that all the traffic is masqueraded so that you can reach the outside world from the containers.
</p>
<div class="listingblock">
<div class="content">
<pre><code>iptables -nvL
iptables -nvL -t nat</code></pre>
</div></div>
</li>
<li>
<p>
What is Docker putting on the file system?  Check <em>/var/lib/docker</em> to see what Docker actually puts down.
</p>
<div class="listingblock">
<div class="content">
<pre><code>ls /var/lib/docker</code></pre>
</div></div>
</li>
<li>
<p>
The root filesystem for the container is in the devicemapper directory.  Grab the <em>Container ID</em> and complete the path below.  Replace &lt;Container UUID&gt; with the output from <em>docker ps -l</em> and use tab completion to complete the &lt;Container UUID&gt;.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker ps -l
ls /var/lib/docker/devicemapper/mnt/&lt;Container ID&gt;&lt;tab&gt;&lt;tab&gt;/rootfs</code></pre>
</div></div>
</li>
<li>
<p>
How do I get the IP address of a running container? Grab the &lt;Container UUID&gt; of a running container.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker ps
docker inspect &lt;Container UUID&gt;</code></pre>
</div></div>
</li>
<li>
<p>
That is quite a lot of output, let&#8217;s add a filter.  Replace &lt;Container ID&gt; with the output of <em>docker ps</em>.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker ps
docker inspect --format '{{ .NetworkSettings.IPAddress }}' &lt;Container UUID&gt;</code></pre>
</div></div>
</li>
<li>
<p>
Stop the container and check out its status. The container will not be running anymore, so it is not visible with <em>docker ps</em>.  To see the &lt;Container ID&gt; of a stopped container, use the <em>-a</em> option.  The <em>-a</em> option shows all containers, started or stopped.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker stop &lt;Container UUID&gt;
docker ps
docker ps -a</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect3">
<h4 id="_where_are_my_logs">Where are my logs?</h4>
<div class="paragraph"><p>The containers do not run syslog.  In order to get logs from the container, there are a couple of methods.  The first is to run the container with <em>/dev/log</em> socket bind mounted inside the container.  The other is to write to external volumes.  That&#8217;s in a later lab.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Launch the container with an interactive shell. The file <em>/dev/log</em> is a socket.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker run -v /dev/log:/dev/log -i -t rhel7 bash</code></pre>
</div></div>
</li>
<li>
<p>
Now that the container is running.  Open another terminal and inspect the bind mount.  Do not run this inside the container.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker ps -l
docker inspect --format '{{.Volumes}}' &lt;Container UUID&gt;</code></pre>
</div></div>
</li>
<li>
<p>
Go back to the original terminal. Generate a message with <em>logger</em> and exit the container.  This should write the message to the host journal.
</p>
<div class="listingblock">
<div class="content">
<pre><code>logger "This is a log Entry"
exit</code></pre>
</div></div>
</li>
<li>
<p>
Check the logs on the host to ensure the bind mount was successful.
</p>
<div class="listingblock">
<div class="content">
<pre><code>journalctl | grep -i "This is a log Entry"</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect3">
<h4 id="_control_that_service">Control that Service!</h4>
<div class="paragraph"><p>We can control services with systemd.  Systemd allows us to start, stop, and control which services are enabled on boot, among many other things.  In this section we will use systemd to enable the <em>nginx</em> service to start on boot.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Have a look at the docker images.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker images</code></pre>
</div></div>
</li>
<li>
<p>
You will notice a repository called <em>demo/nginx</em>, that is what will be used in this section.
</p>
</li>
<li>
<p>
Here is the systemd unit file that needs to be created in order for this to work.  The content below needs to be placed in the <em>/etc/systemd/system/nginx.service</em> file.  This is a trivial file that does not provide full control of the service.
</p>
<div class="listingblock">
<div class="content">
<pre><code>cat &gt; /etc/systemd/system/nginx.service &lt;&lt; EOF
[Unit]
Description=nginx server
After=docker.service

[Service]
Type=simple
ExecStart=/bin/bash -c '/usr/bin/docker start nginx || /usr/bin/docker run --name nginx -p 80:80 demo/nginx'

[Install]
WantedBy=multi-user.target
EOF</code></pre>
</div></div>
</li>
<li>
<p>
Now control the service.  Enable the service on reboot.
</p>
<div class="listingblock">
<div class="content">
<pre><code>systemctl enable nginx.service
systemctl is-enabled nginx.service</code></pre>
</div></div>
</li>
<li>
<p>
Start the service.  When starting this service, make sure there are no other containers using port 80 or it will fail.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker ps
systemctl start nginx.service
docker ps</code></pre>
</div></div>
</li>
</ol></div>
<div class="paragraph"><p>It&#8217;s that easy!</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Before moving to the next lab, ensure that <em>nginx</em> is stopped, or else there will be a port conflict on port 80.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker ps | grep -i nginx</code></pre>
</div></div>
</li>
<li>
<p>
If it is running:
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker stop nginx
systemctl disable nginx.service</code></pre>
</div></div>
</li>
</ol></div>
</div>
</div>
<div class="sect2">
<h3 id="_containers_can_talk">Containers can Talk</h3>
<div class="paragraph"><p>Now that we have the fundamentals down, let&#8217;s do something a bit more interesting with these containers.  This lab will cover launching a <em>MariaDB</em> and <em>Mediawiki</em> container. The two will be tied together via the Docker <em>link</em> functionality.  This lab will build upon things we learned in lab 1 and expand on that.  We&#8217;ll be looking at external volumes, links, and additional options to the Docker <em>run</em> command.</p></div>
<div class="paragraph"><p><strong>A bit about links</strong></p></div>
<div class="paragraph"><p>Straight from the Docker.io site:</p></div>
<div class="paragraph"><p>"Links: service discovery for docker. Links allow containers to discover and securely communicate with each other by using the flag -link name:alias  When two containers are linked together Docker creates a parent child relationship between the containers. The parent container will be able to access information via environment variables of the child such as name, exposed ports, IP and other selected environment variables."</p></div>
</div>
<div class="sect2">
<h3 id="_mariadb">MariaDB</h3>
<div class="paragraph"><p>This section shows how to set up an external volume and use hostnames when launching the MariaDB container.</p></div>
<div class="sect3">
<h4 id="_review_the_mariadb_environment">Review the MariaDB Environment</h4>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Review the scripts and other content that are required to build and launch the <em>MariaDB</em> container.  This lab does not require that you build the container as it has already been done to save time.  Rather, it provides the information you need to understand what the requirements of building a container like this.
</p>
<div class="listingblock">
<div class="content">
<pre><code>cd /root/atomic_host_1/mariadb/; ls</code></pre>
</div></div>
</li>
<li>
<p>
Review the Dockerfile. Look at the <em>Dockerfile</em>. From the contents below, you can see that the Dockerfile is starting with the RHEL7 base image and is maintained by Stephen Tweedie.  After the <em>FROM</em> and <em>MAINTAINER</em> commands are run, the commands to install software are run with <em>RUN</em>.  Think of the <em>RUN</em> command as executing a line in a shell script.  The remaining commands are <em>ADD</em>, which are used to add content to the image and finally <em>EXPOSE</em> and <em>CMD</em> which expose ports and provide the starting command, respectively.  Exposing the port will make the port available to the <em>Mediawiki</em> container when it is launched with the <em>-link</em> command.
</p>
<div class="listingblock">
<div class="content">
<pre><code># cat Dockerfile
FROM fedora:20
MAINTAINER Stephen Tweedie &lt;sct@redhat.com&gt;

RUN yum -y update; yum clean all
RUN yum -y install mariadb-server pwgen supervisor psmisc net-tools; yum clean all

VOLUME [ "/var/lib/mysql" ]

ADD ./start.sh /start.sh
ADD ./supervisord.conf /etc/supervisord.conf

RUN chmod 755 /start.sh

EXPOSE 3306

CMD ["/bin/bash", "/start.sh"]</code></pre>
</div></div>
</li>
<li>
<p>
Review the supervisord.conf file
</p>
</li>
</ol></div>
<div class="paragraph"><p>Straight from the supervisord.org site:</p></div>
<div class="paragraph"><p>"Supervisor: A Process Control System. Supervisor is a client/server system that allows its users to monitor and control a number of processes on UNIX-like operating systems."</p></div>
<div class="paragraph"><p>There are a couple of reasons to use <em>supervisord</em> inside a container.  The first is that Docker really only wants to be in charge of one service.  So if you are running multiple services in a POC container such as MariaDB and Apache at the same time, you need a way to manage those. Present <em>supervisord</em> as the service that runs on launch and let it control the other services in the background. Also, supervisord can run services in foreground mode.  Docker likes that.</p></div>
<div class="paragraph"><p>The <em>supervisord.conf</em> file instructs the <em>supervisord</em> daemon as to which processes it is responsible for.  This <em>supervisord.conf</em> file has been pared down considerably.</p></div>
<div class="listingblock">
<div class="content">
<pre><code># cat supervisord.conf
[unix_http_server]
file=/tmp/supervisor.sock   ; (the path to the socket file)

[supervisord]
logfile=/tmp/supervisord.log ; (main log file;default $CWD/supervisord.log)
logfile_maxbytes=50MB        ; (max main logfile bytes b4 rotation;default 50MB)
logfile_backups=10           ; (num of main logfile rotation backups;default 10)
loglevel=info                ; (log level;default info; others: debug,warn,trace)
pidfile=/tmp/supervisord.pid ; (supervisord pidfile;default supervisord.pid)
nodaemon=false               ; (start in foreground if true;default false)
minfds=1024                  ; (min. avail startup file descriptors;default 1024)
minprocs=200                 ; (min. avail process descriptors;default 200)

[rpcinterface:supervisor]
supervisor.rpcinterface_factory = supervisor.rpcinterface:make_main_rpcinterface

[supervisorctl]
serverurl=unix:///tmp/supervisor.sock ; use a unix:// URL  for a unix socket

[program:mariadb]
command=/usr/bin/mysqld_safe
stdout_logfile=/var/log/supervisor/%(program_name)s.log
stderr_logfile=/var/log/supervisor/%(program_name)s.log
autorestart=true</code></pre>
</div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Review the start.sh script
The <em>start.sh</em> script is called by the container to start the <em>supervisord</em> daemon.  The first thing the <em>start.sh</em> script does is checks to see if the database has been created yet.  If it has, just start the container, if not, create it.  The reason for this is this container uses a shared volume.  It only needs to create the database one time.  All other times the container starts, use existing data.
</p>
<div class="listingblock">
<div class="content">
<pre><code># cat start.sh
#!/bin/bash -x

__mysql_config() {

if [ ! -f /mariadb/db/ibdata1 ]; then
  echo
  echo "Database does not exist, creating now."
  echo
  sleep 2
  mysql_install_db
  chown -R mysql:mysql /var/lib/mysql
  /usr/bin/mysqld_safe &amp;
  sleep 10

  echo "Running the start_mysql function."
  mysqladmin -u root password mysqlPassword
  mysql -uroot -pmysqlPassword -e "CREATE DATABASE testdb"

  mysql -uroot -pmysqlPassword -e "GRANT ALL PRIVILEGES ON testdb.* \
  TO 'testdb'@'localhost' IDENTIFIED BY 'mysqlPassword'; FLUSH PRIVILEGES;"

  mysql -uroot -pmysqlPassword -e "GRANT ALL PRIVILEGES ON *.* \
  TO 'testdb'@'%' IDENTIFIED BY 'mysqlPassword' WITH GRANT OPTION; FLUSH PRIVILEGES;"

  mysql -uroot -pmysqlPassword -e "GRANT ALL PRIVILEGES ON *.* \
  TO 'root'@'%' IDENTIFIED BY 'mysqlPassword' WITH GRANT OPTION; FLUSH PRIVILEGES;"

  mysql -uroot -pmysqlPassword -e "select user, host FROM mysql.user;"
  killall mysqld
  sleep 10
fi
}

__run_supervisor() {
echo "Running the run_supervisor function."
supervisord -n
}

# Call all functions
__mysql_config
__run_supervisor</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect3">
<h4 id="_launch_the_mariadb_container">Launch the MariaDB Container</h4>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Either tail the audit log from your current terminal by placing the tail command in the background:
</p>
<div class="listingblock">
<div class="content">
<pre><code>tail -f /var/log/audit/audit.log | grep -i avc &amp;</code></pre>
</div></div>
</li>
<li>
<p>
Or open another terminal and watch for AVCs in the foreground:
</p>
<div class="listingblock">
<div class="content">
<pre><code>tail -f /var/log/audit/audit.log | grep -i avc</code></pre>
</div></div>
</li>
<li>
<p>
Launch the container.  The /mariadb/db directory already exists and has database content inside.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker run -d -v /mariadb/db:/var/lib/mysql -p 3306:3306 --name mariadb demo/mariadb</code></pre>
</div></div>
</li>
<li>
<p>
Did the container start as expected?  You should see some AVC&#8217;s.  Look at the logs on the container and see the <em>permission denied</em> messages.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker logs mariadb</code></pre>
</div></div>
</li>
<li>
<p>
You will need to allow the proper SELinux permissions on the local <em>/mariadb/db</em> directory so <em>MariaDB</em> can access the directory.  Right now it&#8217;s at <em>default_t</em>, this needs to be changed per below.
</p>
<div class="listingblock">
<div class="content">
<pre><code>ls -lZd /mariadb/db
chcon -Rvt svirt_sandbox_file_t /mariadb/db/</code></pre>
</div></div>
</li>
<li>
<p>
Now launch the container again.  First the container will have to be removed because of a naming conflict.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker ps -a
docker stop mariadb &amp;&amp; docker rm mariadb</code></pre>
</div></div>
</li>
<li>
<p>
Launch the container again.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker run -d -v /mariadb/db:/var/lib/mysql -p 3306:3306 --name mariadb demo/mariadb
docker ps -l
docker logs mariadb</code></pre>
</div></div>
</li>
</ol></div>
<div class="paragraph"><p>The container should be running at this time. Kill the background <em>tail -f</em> process if you want.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_mediawiki">Mediawiki</h3>
<div class="paragraph"><p>This section shows how to launch the <em>Mediawiki</em> container and link it back to the <em>MariaDB</em> container.</p></div>
<div class="sect3">
<h4 id="_review_the_mediawiki_environment">Review the Mediawiki Environment</h4>
<div class="paragraph"><p>Review the scripts and other content that are required to build and launch the <em>Mediawiki</em> container and link it to the <em>MariaDB</em> container.  This lab does not require that you build the container as it has already been done in the prior lab.  Rather, it provides the information you need to understand what the requirements of building a container like this.  The files are pasted here, but they are also in <em>/root/atomic_host_1/mediawiki</em></p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Review the Dockerfile
</p>
<div class="listingblock">
<div class="content">
<pre><code>cat Dockerfile
FROM fedora:20
MAINTAINER Stephen Tweedie &lt;sct@redhat.com&gt;

# Basic RPM install...
RUN yum -y update; yum clean all

# Install:
#  Mediawiki, obviously
#  php, because mediawiki doesn't by itself install php into apache
#  php-mysqlnd: this image will be configured to run against the
#               Fedora-Dockerfiles mariadb image so we need the mysqld
#               client support for php
RUN yum -y install mediawiki php php-mysqlnd; yum clean all

# Now wiki data.  We'll expose the wiki at $host/wiki, so the html root will be
# at /var/www/html/wiki; to allow this to be used as a data volume we keep the
# initialisation in a separate script.

ADD ./config.sh /config.sh
ADD ./run-apache.sh /run-apache.sh
ADD ./LocalSettings.php /var/www/html/wiki/
RUN chmod +x /run-apache.sh
RUN chmod +x /config.sh
RUN /config.sh

# localhost:/wiki/mw-config should now be available to configure mediawiki.

# Add script to update the IP address of a linked mariadb container if
# needed:

ADD run-mw.sh /run-mw.sh
RUN chmod +x /run-mw.sh
CMD ["/run-mw.sh"]</code></pre>
</div></div>
</li>
<li>
<p>
Review the config.sh script
</p>
<div class="listingblock">
<div class="content">
<pre><code># cat config.sh
#!/bin/bash
#
# The mediawiki rpm installs into /var/www/wiki.  We need to symlink this into
# the served /var/www/html/ tree to make them visible.
#
# Standard config will put these in /var/www/html/wiki (ie. visible at
# http://$HOSTNAME/wiki )

mkdir -p /var/www/html/wiki

cd /var/www/html/wiki
ln -sf ../../wiki/* .

# We want /var/www/html/wiki to be usable as a data volume, so it's
# important that persistent data lives here, not in /var/www/wiki.

chmod 711 .
rm -f images
mkdir images
chown apache.apache images</code></pre>
</div></div>
</li>
<li>
<p>
Review the run-mw.sh script
</p>
<div class="listingblock">
<div class="content">
<pre><code># cat run-mw.sh
#!/bin/bash
#
# Run mediawiki in a docker container environment.

function edit_in_place () {
    tmp=`mktemp`
    sed -e "$2" &lt; "$1" &gt; $tmp
    cat $tmp &gt; "$1"
    rm $tmp
}

# If we are talking to a mariadb/mysql instance in a linked container
# (aliased "db" on port 3306), then we need to dynamically update the
# MW config to refer to the correct DB server IP address.
#
# Docker will set the DB_PORT_3306_TCP_ADDR env variable to the right
# IP in this case.
#
# We'll update lines like
#   $wgDBserver = "localhost";
# to point to the correct location.

if [ "x$DB_PORT_3306_TCP_ADDR" != "x" ] ; then
    # For initial configuration, it's also considerate to update the
    # default settings that drive the config screen defaults
    edit_in_place /usr/share/mediawiki/includes/DefaultSettings.php 's/^\$wgDBserver =.*$/\$wgDBserver = "'$DB_PORT_3306_TCP_ADDR'";/'

    # Only update LocalSettings if they already exist; on initial
    # setup they will not yet be here
    if [ -f /var/www/html/wiki/LocalSettings.php ] ; then
        edit_in_place /var/www/html/wiki/LocalSettings.php 's/^\$wgDBserver =.*$/\$wgDBserver = "'$DB_PORT_3306_TCP_ADDR'";/'
        sed -i 's/^\$wgServer =.*$/\$wgServer = "http:\/\/'$HOST_IP'";/' /var/www/html/wiki/LocalSettings.php
    fi
fi


# Finally fall through to the apache startup script that the apache
# Dockerfile (which we build on top of here) sets up
exec /run-apache.sh</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect3">
<h4 id="_launch_the_mediawiki_container">Launch the Mediawiki Container</h4>
<div class="paragraph"><p>This section show&#8217;s how to use hostnames and link to an existing container.  Issue the <em>docker run</em> command and link to the <em>mariadb</em> container.</p></div>
<div class="paragraph"><p>Run the container.  The command below is taking the enviroment variable <em>HOST_IP</em> and will inject that into the <em>run-mw.sh</em> script when the container is launched. The <em>HOST_IP</em> is the IP address of the virtual machine that is hosting the container.  Replace IP_OF_VIRTUAL_MACHINE with the IP address of the virtual machine running the container.</p></div>
<div class="paragraph"><p>[NOTE] In the following command, after the <em>-e</em>, leave the <em>HOST_IP</em> entry.  It&#8217;s used to hold the variable of the IP address of the Atomic Host 1 virtual machine.</p></div>
<div class="listingblock">
<div class="content">
<pre><code>ip a

docker run -d -e=HOST_IP=IP_OF_VIRTUAL_MACHINE --link mariadb:db  -v /var/www/html/ -p 80:80 --name mediawiki summit/mediawiki</code></pre>
</div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Explore the link that was made.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker ps | grep media</code></pre>
</div></div>
</li>
</ol></div>
<div class="admonitionblock">
<table><tr>
<td class="icon">
<img alt="Note" src="data:image/png;base64,
" />
</td>
<td class="content">Notice in the <em>NAMES</em> column on the mariadb container and how the link is represented.</td>
</tr></table>
</div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Inspect the container and get volume information:
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker inspect --format '{{ .Volumes }}' mediawiki</code></pre>
</div></div>
</li>
<li>
<p>
Now take the output of the <em>docker inspect</em> command and use the UUID from that in the next command.  Explore the mediawiki content.  This directory is mapped to <em>/var/www/html/wiki</em> inside the container.
<br />
</p>
</li>
</ol></div>
<div class="listingblock">
<div class="content">
<pre><code>ls /var/lib/docker/vfs/dir/&lt;UUID Listed from Prior Query&gt;/wiki</code></pre>
</div></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
For example:
</p>
<div class="listingblock">
<div class="content">
<pre><code>ls /var/lib/docker/vfs/dir/1c8c23c24ebaea8e00fb8639e545c662516445faee7dcd5d89882fdbf1fd638d/wiki</code></pre>
</div></div>
</li>
<li>
<p>
Take a look at the logs for the container and notice how the IP substitutions were done.  One IP address is for the MariaDB host and one IP address is the virtual machine IP address.  It&#8217;s the same IP address that was passed via the <em>docker run</em> command.
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker logs mediawiki</code></pre>
</div></div>
</li>
<li>
<p>
Open browser on the host running the VM and confirm the configuration is complte.
</p>
<div class="listingblock">
<div class="content">
<pre><code>firefox &amp;</code></pre>
</div></div>
</li>
<li>
<p>
Go to the <em>Mediawiki</em> home page. Use the IP address of the virtual machine.  The same IP address that was passed in as the HOST_IP in the docker run command.
</p>
<div class="listingblock">
<div class="content">
<pre><code>http://ip.address.here/wiki</code></pre>
</div></div>
</li>
<li>
<p>
Thats it.  Now you can start using your wiki. You can click on <em>Create Account</em> in the top right and test it out, or log in with:
</p>
<div class="listingblock">
<div class="content">
<pre><code>Username: admin&lt;br&gt;
Passwrod: redhat</code></pre>
</div></div>
</li>
<li>
<p>
Now, how did this work?  The way this works is that the Dockerfile <em>CMD</em> command tells the container to launch with the <em>run-mw.sh</em> script.  Here&#8217;s the key thing about what that script is doing, let&#8217;s review:
</p>
<div class="listingblock">
<div class="content">
<pre><code>if [ "x$DB_PORT_3306_TCP_ADDR" != "x" ] ; then
    # For initial configuration, it's also considerate to update the
    # default settings that drive the config screen defaults
    edit_in_place /usr/share/mediawiki/includes/DefaultSettings.php 's/^\$wgDBserver =.*$/\$wgDBserver = "'$DB_PORT_3306_TCP_ADDR'";/'

    # Only update LocalSettings if they already exist; on initial
    # setup they will not yet be here
    if [ -f /var/www/html/wiki/LocalSettings.php ] ; then
        edit_in_place /var/www/html/wiki/LocalSettings.php 's/^\$wgDBserver =.*$/\$wgDBserver = "'$DB_PORT_3306_TCP_ADDR'";/'
        sed -i 's/^\$wgServer =.*$/\$wgServer = "http:\/\/'$HOST_IP'";/' /var/www/html/wiki/LocalSettings.php
    fi
fi</code></pre>
</div></div>
</li>
</ol></div>
<div class="paragraph"><p>It&#8217;s doing a check for an existing LocalSettings.php file.  We added that file during the Docker build process.  That file was copied to /var/www/html/wiki.  So, the script runs, sees that the file exists and points the <em>$wbDBserver</em> variable to the MariaDB container.  So, no matter if these containers get shut down and have new IP addresses, the Mediawiki container will always be able to find the MariaDB container because of the <em>link</em>.  In addition, it&#8217;s using the <em>-e</em> option to pass environment variables, in this case, $HOST_IP to the <em>run-mw.sh</em> script to complete the configuration.</p></div>
</div>
</div>
<div class="sect2">
<h3 id="_continue_your_learning">Continue your Learning</h3>
<div class="sect3">
<h4 id="_how_to_install">How to Install</h4>
<div class="paragraph"><p>On a Fedora host</p></div>
<div class="literalblock">
<div class="content">
<pre><code>yum install fedora-dockerfiles docker-io</code></pre>
</div></div>
</div>
<div class="sect3">
<h4 id="_more_information">More Information</h4>
<div class="paragraph"><p>Project Atomic site:</p></div>
<div class="paragraph"><p><a href="http://projectatomic.io">http://projectatomic.io</a></p></div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="geard">Introduction to geard</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_geard">geard</h3>
<div class="paragraph"><p>geard is a Docker container orchestration tool.  At the currrent release, it essentially does three things:</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
SSH
</p>
</li>
<li>
<p>
Multiple container deployment
</p>
</li>
<li>
<p>
Link
</p>
</li>
</ol></div>
<div class="paragraph"><p>This lab has 5 parts.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Single host / single container deployment
</p>
</li>
<li>
<p>
Single host / multi container deployment
</p>
</li>
<li>
<p>
Single host / MongoDB replica set configuration
</p>
</li>
<li>
<p>
Multi host container linking
</p>
</li>
<li>
<p>
SSH enablement for contianers
</p>
</li>
</ol></div>
</div>
<div class="sect2">
<h3 id="_geard_lab_prerequisites">geard Lab Prerequisites</h3>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Two Atomic hosts
</p>
<div class="listingblock">
<div class="content">
<pre><code>hostname   # on host 1
hostname   # on host 2</code></pre>
</div></div>
</li>
<li>
<p>
Check to see that geard and Docker are installed and running
</p>
<div class="listingblock">
<div class="content">
<pre><code>rpm -qa | grep -i geard
rpm -qa | grep -i docker
systemctl status geard
systemctl status docker</code></pre>
</div></div>
</li>
<li>
<p>
Check for the proper .json files in the users home directory
</p>
<div class="listingblock">
<div class="content">
<pre><code>ls *.json
http_single.json  mongo_deploy.json</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect2">
<h3 id="_deploy_a_single_container_br">Deploy a Single Container<br /></h3>
<div class="paragraph"><p><strong>On host 1:</strong></p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Check which units geard has registered
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear list-units</code></pre>
</div></div>
</li>
<li>
<p>
Check to see which images are available and running within Docker
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker images
docker ps</code></pre>
</div></div>
</li>
<li>
<p>
Install the first unit
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear install demo/apache web-server --start -p 80:80</code></pre>
</div></div>
</li>
<li>
<p>
List the units again
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear list-units</code></pre>
</div></div>
</li>
<li>
<p>
Show the container is also recognized by Docker
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker ps</code></pre>
</div></div>
</li>
<li>
<p>
Make sure the web server is responding to requests
</p>
<div class="listingblock">
<div class="content">
<pre><code>curl http://localhost</code></pre>
</div></div>
</li>
<li>
<p>
List the units one more time
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear list-units</code></pre>
</div></div>
</li>
<li>
<p>
Clean up the environmentnd
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear delete web-server
gear list-units</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect2">
<h3 id="_deploy_multiple_containers_on_a_single_host">Deploy Multiple Containers on a Single Host</h3>
<div class="paragraph"><p><strong>On host 1:</strong></p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Check the geard environment
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear list-units
docker ps</code></pre>
</div></div>
</li>
<li>
<p>
Check out the <em>http_single_HTB.json</em> file
</p>
<div class="listingblock">
<div class="content">
<pre><code>cat http_single_HTB.json
{
  "Containers": [
    {
      "Name": "web-server",
      "Image": "demo/apache",
      "PublicPorts": [
        {
          "Internal": 80
        }
      ],
      "Links": [
        {
          "To": "web-server",
          "NonLocal": true,
          "MatchPort": true
        }
      ],
      "Count": 3
    }
  ],
  "IdPrefix": "",
  "RandomizeIds": false
}</code></pre>
</div></div>
</li>
</ol></div>
<div class="paragraph"><p>This file tells geard to deploy an application with <em>Name</em> "web-server", to use <em>image</em> "demo/apache" with an internal port of 80 and a count of 3.</p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Check out the <em>/var/lib/containers/</em> directory.  This is where geard stores it&#8217;s content. Right now there will not be any content in the <em>units</em> directory.  After a successful launch of the application there will be.
</p>
<div class="listingblock">
<div class="content">
<pre><code>ls /var/lib/containers/
ls /var/lib/containers/units/</code></pre>
</div></div>
</li>
<li>
<p>
Deploy the application. This tells geard to deploy all three web servers on the same host.
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear deploy http_single_HTB.json</code></pre>
</div></div>
</li>
<li>
<p>
Check the <em>/var/lib/containers/</em> directory again to see what content geard added
</p>
<div class="listingblock">
<div class="content">
<pre><code>ls /var/lib/containers/
ls /var/lib/containers/units/</code></pre>
</div></div>
</li>
<li>
<p>
Check <em>systemd</em> integration
</p>
<div class="listingblock">
<div class="content">
<pre><code>systemctl status ctr-web-server-1</code></pre>
</div></div>
</li>
<li>
<p>
Check to ensure the web servers are registered with geard and Docker
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear list-units
docker ps</code></pre>
</div></div>
</li>
<li>
<p>
Now that we have the ports listed as shown in <em>docker ps</em>, let&#8217;s make sure one of the web servers are running.
</p>
<div class="listingblock">
<div class="content">
<pre><code>curl http://localhost:4000</code></pre>
</div></div>
</li>
<li>
<p>
Clean up the environment
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear list-units
gear delete web-server{1,2,3}
gear list-units
docker ps</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect2">
<h3 id="_deploy_a_mongodb_replica_set_on_a_single_host">Deploy a MongoDB replica set on a single host</h3>
<div class="paragraph"><p><strong>On host 1:</strong></p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Check the environment
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear list-units
docker ps</code></pre>
</div></div>
</li>
<li>
<p>
Explore the <em>mongo_deploy.json</em>, notice the name, count and image.  The .json file is also taking care of the linking.
</p>
<div class="listingblock">
<div class="content">
<pre><code>cat mongo_deploy.json
{
  "containers":[
    {
      "name":"db",
      "count":3,
      "image":"demo/mongo",
      "publicports":[
        {"internal":27017,"external":0}
      ],
      "links":[
        {"to":"db","nonlocal":true,"matchport":true}
      ]
    }
  ]
}</code></pre>
</div></div>
</li>
<li>
<p>
Deploy the application
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear deploy mongo_deploy.json</code></pre>
</div></div>
</li>
<li>
<p>
List the units and container
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear list-units
docker ps</code></pre>
</div></div>
</li>
<li>
<p>
Connect with the MongoDB client
</p>
<div class="listingblock">
<div class="content">
<pre><code>mongo --host localhost --port "PUT PORT HERE"</code></pre>
</div></div>
</li>
<li>
<p>
Copy in the configuration file
</p>
<div class="listingblock">
<div class="content">
<pre><code>cat mongo_replica_json
cfg = {
    "_id" : "replica0",
    "version" : 1,
    "members" : [
        {
            "_id" : 0,
            "host" : "192.168.1.1:27017"
        },
        {
            "_id" : 1,
            "host" : "192.168.1.2:27017"
        },
        {
            "_id" : 2,
            "host" : "192.168.1.3:27017"
        },
    ]
}</code></pre>
</div></div>
</li>
<li>
<p>
Initiate the replica set
</p>
<div class="listingblock">
<div class="content">
<pre><code>&gt; rs.initiate(cfg)</code></pre>
</div></div>
</li>
<li>
<p>
Refresh the configuration until you see PRIMARY and SECONDARY
</p>
<div class="listingblock">
<div class="content">
<pre><code>&gt; rs.status()
&gt; rs.status()
&gt; rs.status()</code></pre>
</div></div>
</li>
<li>
<p>
Clean up the environment
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear list-units
docker ps
gear delete db-{1,2,3}
gear list-units
docker ps</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect2">
<h3 id="_multi_host_application_linking">Multi-host Application Linking</h3>
<div class="paragraph"><p><strong>On host 1:</strong></p></div>
<div class="olist arabic"><ol class="arabic">
<li>
<p>
Check the environment
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear list-units
docker ps</code></pre>
</div></div>
</li>
<li>
<p>
Explore the <em>http_single.json</em> file
</p>
<div class="listingblock">
<div class="content">
<pre><code>cat http_single.json
{
  "Containers": [
    {
      "Name": "web-server",
      "Image": "demo/apache",
      "PublicPorts": [
        {
          "Internal": 80
        }
      ],
      "Links": [
        {
          "To": "web-server",
          "NonLocal": true,
          "MatchPort": true
        }
      ],
      "Count": 2
    }
  ],
  "IdPrefix": "",
  "RandomizeIds": false
}</code></pre>
</div></div>
</li>
<li>
<p>
Ensure that the geard and Docker daemons are running on the second host.
</p>
<div class="listingblock">
<div class="content">
<pre><code>systemctl status docker  # on host 1
systemctl status docker  # on host 2
systemctl status geard  # on host 1
systemctl status geard  # on host 2</code></pre>
</div></div>
</li>
<li>
<p>
Deploy the application on both hosts, where <strong>x.x.x.x</strong> is the IP address of the second host
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear deploy http_single.json localhost x.x.x.x</code></pre>
</div></div>
</li>
<li>
<p>
List the units and containers on both hosts
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear list-units    # on host 1
gear list-units    # on host 2
docker ps          # on host 1
docker ps          # on host 2</code></pre>
</div></div>
</li>
<li>
<p>
On host 1, get the pid for the web server container
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker inspect --format '{{ .State.Pid }}' &lt;container uid&gt;</code></pre>
</div></div>
</li>
<li>
<p>
Use <em>nsenter</em> to enter the namespace of the PID and take a look at the IPtables rules. You will see that there is a rule forwarding all traffic to <em>192.168.1.x</em> to the external port on the localhost and the external port on the remote host.  Basically geard is telling the container that every application is local.
</p>
<div class="listingblock">
<div class="content">
<pre><code>nsenter -m -u -n -i -p -t &lt;PID FROM &lt;container uid&gt;&gt; bash
iptables -nvL -t nat</code></pre>
</div></div>
</li>
<li>
<p>
Ensure that you can get the index.html from each host
</p>
<div class="listingblock">
<div class="content">
<pre><code>curl http://localhost:&lt;external port localhost&gt;
curl http://localhost:&lt;external port remote host&gt;</code></pre>
</div></div>
</li>
<li>
<p>
On host 2, ensure that you can pull that web page as well and compare to the output that you got inside the container on host 1
</p>
<div class="listingblock">
<div class="content">
<pre><code>docker ps
curl http://localhost:&lt;external port localhost&gt;</code></pre>
</div></div>
</li>
<li>
<p>
Clean up the environment
</p>
<div class="listingblock">
<div class="content">
<pre><code>gear list-units   # on host 1
gear list-units   # on host 2
gear delete web-server-1    # on host 1
gear delete web-server-2    # on host 2</code></pre>
</div></div>
</li>
</ol></div>
</div>
<div class="sect2">
<h3 id="_ssh_enablement_for_containers">SSH Enablement for Containers</h3>
<div class="paragraph"><p><strong>On host 1:</strong></p></div>
<div class="paragraph"><p>TBD</p></div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="Upgrade_Rollback">Upgrading and Rolling back a Project Atomic Host</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_project_atomic_host_upgrade_and_rollback">Project Atomic Host Upgrade and Rollback</h3>
<div class="paragraph"><p>Need to put instructions for pulling a new tree and rollback</p></div>
</div>
</div>
</div>
</div>
<div id="footnotes"><hr /></div>
<div id="footer">
<div id="footer-text">
Last updated 2014-05-27 19:54:20 CDT
</div>
</div>
</body>
</html>
